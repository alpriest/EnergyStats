//
//  GraphTabViewModel.swift
//  Energy Stats
//
//  Created by Alistair Priest on 08/09/2022.
//

import Foundation
import SwiftUI

struct GraphVariable: Identifiable, Equatable {
    let type: GraphVariableType
    var enabled = true
    var id: String { type.title }

    init(_ type: GraphVariableType, enabled: Bool = true) {
        self.type = type
        self.enabled = enabled
    }
}

enum GraphVariableType: String, RawRepresentable {
    case feedinPower
    case generationPower
    case gridConsumptionPower
    case batChargePower
    case pvPower

    var description: String {
        switch self {
        case .feedinPower:
            return "Power being sent to the grid"
        case .generationPower:
            return "Power coming through the inverter"
        case .gridConsumptionPower:
            return "Power coming from the grid"
        case .batChargePower:
            return "Power charging the battery"
        case .pvPower:
            return "Power generated by the solar panels"
        }
    }

    var title: String {
        switch self {
        case .feedinPower:
            return "Grid export"
        case .generationPower:
            return "Generation Power"
        case .gridConsumptionPower:
            return "Grid import"
        case .batChargePower:
            return "Battery Charge Power"
        case .pvPower:
            return "Solar Power"
        }
    }

    var colour: Color {
        switch self {
        case .feedinPower:
            return .blue.opacity(0.8)
        case .generationPower:
            return .mint.opacity(0.8)
        case .gridConsumptionPower:
            return .red.opacity(0.8)
        case .batChargePower:
            return .green.opacity(0.8)
        case .pvPower:
            return .yellow.opacity(0.8)
        }
    }

    init?(fromReport variable: String) {
        switch variable {
        case "feedin":
            self = GraphVariableType.feedinPower
        case "generation":
            self = GraphVariableType.generationPower
        case "gridConsumption":
            self = GraphVariableType.gridConsumptionPower
        case "pvPower":
            self = GraphVariableType.pvPower
        default:
            return nil
        }
    }
}

class GraphTabViewModel: ObservableObject {
    private var networking: Networking
    private var rawData: [GraphValue] = [] {
        didSet {
            data = rawData
        }
    }

    private var totals: Dictionary<GraphVariableType, Double> = [:]

    @Published var data: [GraphValue] = []
    @Published var variables: [GraphVariable] = [GraphVariable(.feedinPower), GraphVariable(.gridConsumptionPower), GraphVariable(.generationPower), GraphVariable(.batChargePower), GraphVariable(.pvPower)]

    init(_ networking: Networking) {
        self.networking = networking
    }

    func start() {
        Task {
            let raw = try await networking.fetchRaw(variables: variables.map { $0.type.rawValue })
            let report = try await networking.fetchReport()

            let data: [GraphValue] = raw.result.flatMap { reportVariable in
                reportVariable.data.compactMap {
                    guard let variable = GraphVariableType(rawValue: reportVariable.variable) else { return nil }
                    return GraphValue(date: $0.time, value: $0.value, variable: variable)
                }
            }

            report.result.forEach { reportVariable in
                guard let variable = GraphVariableType(fromReport: reportVariable.variable) else { return }
                let total = reportVariable.data.map { $0.value }.reduce(0, +)

                self.totals[variable] = total
            }

            await MainActor.run { self.rawData = data }
        }
    }

    func refresh() {
        let hiddenVariables = variables.filter { $0.enabled == false }.map { $0.type }
        data = rawData.filter { !hiddenVariables.contains($0.variable) }
    }

    func total(of type: GraphVariableType) -> Double? {
        guard totals.keys.contains(type) else { return nil }

        return totals[type]
    }
}

struct GraphValue: Identifiable {
    let date: Date
    let value: Double
    let variable: GraphVariableType

    var id: Date { date }
}
